\begin{flushleft}
\setcounter{page}{1}
\section{Einleitung}
In der folgenden Projektdokumentation stellt der Autor den Projektablauf dar, der im Rahmen seiner
Ausbildung zum Fachinformatiker für Anwendungsentwicklung durchgeführt wurde. Die Durchführung der
Projektarbeit erfolgt bei der Gesellschaft für Systemtechnik, Softwareentwicklung und
Datenverarbeitungsservice mbH \acs{GSSD} in Teltow. Zur Zeit beschäftigt die \acs{GSSD} vier Mitarbeiter und
betreut verschiedene kleine und mittlere Unternehmen als IT-Dienstleister. Des Weiteren ist die \acs{GSSD}
Partner verschiedener Warenwirtschaftssoftware und bietet in diesem Umfeld Anpassung und
Individualisierung an. Zweites Standbein ist der Vertrieb von Hardware für Unternehmen und Privatkunden
sowie deren Installation und Wartung.



\subsection{Projektbeschreibung}
Ein Kunde von der \acs{GSSD} verwendet auf seinen Servern verschiedene Anwendungen, die als
Dienste oder im Hintergrund laufen. Es muss sichergestellt werden, dass diese Anwendungen
ständig funktionieren. Gegenwärtig gibt es ein Überwachungssystem, das nur unvollständige
Zustände anzeigt. Deswegen werde ein Überwachungssystem für verschiedene Anwendungen, die auf Servern laufen, entwicklen.
Ziel des Projekts ist es, ein Dashboard zu erstellen, auf dem der Status der Anwendungen angezeigt wird.
Das Überwachungssystem wird als Backend- und Frontend-Anwendung umgesetzt und ermöglicht es dem Administrator, alle verfügbaren Anwendungen sowie deren Zusammenarbeit zu überwachen.
Die Anwendungen selbst liefern regelmäßig Informationen über ihren Zustand und ihre Tätigkeit, die in Datenbanktabellen geschrieben werden.
Das Backend liest diese Informationen aus und bewertet sie, bevor sie im Frontend angezeigt werden.
Der Austausch von Informationen zwischen Frontend und Backend erfolgt über ein Websocket.
Jeder Nutzer kann den Status der Anwendungen auf dem Frontend überprüfen, solange er eine Verbindung hat.
Eine Filterfunktion ermöglicht es dem Backend, die Ausgabe einzuschränken.



\subsection{Projektziel}
Ziel des Überwachungssystems ist die Echtzeit-Darstellung von Anwendungsstatus auf einem Dashboard,
um Administratoren die Überwachung von Anwendungen und Interaktionen zu ermöglichen. Anwendungen liefern periodisch Daten,
die in Datenbanktabellen gespeichert und vom Backend analysiert werden. Frontend und Backend kommunizieren via Websocket.
Nutzer können Anwendungsstatus einsehen und neue Sensoren registrieren. Umgesetzt wird das System mit
HTML, VueJs, CSS, Bash, SQL und NodeJs. Bei kritischen Fehlern erhält der Administrator Benachrichtigungen zur Intervention.


\subsection{Projektbegründung}
Effektive Überwachung von Anwendungen und Systemen ist in der Informationstechnologie essenziell,
da sie eine frühzeitige Fehlererkennung ermöglicht und negative Auswirkungen auf Betrieb und Verfügbarkeit vermeidet.
Ein zuverlässiges Überwachungssystem erlaubt dem Administrator, Leistung und Zustand von Komponenten zu überwachen,
um schnell auf Probleme zu reagieren. Dies verbessert Qualität und Verfügbarkeit der Anwendungen und steigert die Kundenzufriedenheit.
Durch die Implementierung eines solchen Systems wird eine reibungslose IT-Infrastruktur und hohe Kundenzufriedenheit sichergestellt.

\subsection{Projektschnittstellen}
Das Projekt beinhaltet folgende Schnittstellen:
\begin{itemize}
\item Geschäftsführung: Für Information über Projektfortschritte und Entscheidungen, die das Projekt beeinflussen.
\item IT-Abteilung: Zuständig für die technische Umsetzung und enge Zusammenarbeit mit dem Projektteam.
\item Externe Dienstleister: Schnittstellen müssen definiert werden, um Kompatibilität mit externen Systemen zu gewährleisten.
\item Benutzer: Einbindung und Information über Änderungen, um den Anforderungen gerecht zu werden.
\item Datenbanken und Anwendungen: Kommunikation mit anderen Datenbanken und Anwendungen zur Informationsverarbeitung.
\item Netzwerk- und Sicherheitsinfrastruktur: Definition von Schnittstellen für mögliche Änderungen an Netzwerk- und Sicherheitsinfrastruktur.
\end{itemize}
Die Umsetzung erfordert enge Zusammenarbeit, klare Verantwortlichkeiten und Kommunikationswege, um alle Beteiligten zu informieren und Probleme schnell zu lösen.


\subsection{Projektbegrenzung}
\begin{itemize}
\item Sensorbau ist nicht Teil des Projekts.
\item Fokus liegt auf der Überwachung interner Anwendungen und Systeme, nicht auf externen Dienstleistungen.
\item Implementierung betrifft hochpriorisierte interne und externe Systeme oder Dienstleistungen.
\item Anpassungen an bestehenden Anwendungen oder Systemen sind ausgeschlossen; Fokus liegt auf Überwachungssystem-Implementierung.
\item Budgetgrenzen schließen umfangreiche IT-Infrastruktur- oder Anwendungsänderungen aus.
\item Implementierung erfolgt innerhalb eines festgelegten Zeitrahmens.
\item Benutzer- oder Mitarbeiterschulungen sind nicht inbegriffen.
\item Überwachungssystem wird nur von einem spezifischen Team oder Abteilung genutzt, nicht von der gesamten Belegschaft.
\end{itemize}


\subsection{Anwendungsfälle}
\begin{itemize}
	\item Anwendungsfall 1: Überwachungssystem ermöglicht Administratoren, Systemzustand einzusehen und auf potenzielle Probleme frühzeitig zu reagieren.
	\begin{itemize}
	\item Akteur: Administrator (verantwortlich für Systemüberwachung und Problemlösung)
	\item Beschreibung:
	\begin{enumerate}
	\item Administrator öffnet Dashboard.
	\item Dashboard zeigt Anwendungsübersicht und aktuellen Zustand.
	\item Administrator filtert Anwendungsliste nach Kriterien.
	\item Bewertung jeder Anwendung wird angezeigt.
	\item Bei kritischem Zustand oder Problem wird Administrator benachrichtigt.
	\item Administrator reagiert auf Benachrichtigung (Problem lösen, System normalisieren).
	\item Administrator passt Überwachungssystem an (Bewertungsfaktoren ändern, Anwendungen hinzufügen).
	\end{enumerate}
	\item Alternativszenarien:
	\begin{itemize}
	\item Bei Dashboard-Problemen informiert der Administrator und löst das Problem oder kontaktiert den Support.
	\item Bei fehlenden Anwendungsinformationen wird der Administrator benachrichtigt und behebt das Problem oder passt Anwendungen an.
	\item Administrator überprüft und passt Bewertungsfaktoren an, wenn Überwachungssystem keine erwarteten Probleme anzeigt.
	\end{itemize}
	\end{itemize}
	\item Anwendungsfall 2: Entwickler registrieren neue Sensoren.
	\begin{itemize}
		\item Akteur: Entwickler (verantwortlich für das Hinzufügen neuer Sensoren zum System)
		\item Beschreibung:
		\begin{enumerate}
			\item Entwickler öffnet Sensorregistrierungsseite im Überwachungssystem.
			\item Entwickler gibt erforderliche Informationen für den neuen Sensor ein.
			\item Überwachungssystem validiert eingegebene Informationen.
			\item Bei erfolgreicher Validierung wird neuer Sensor dem System hinzugefügt und in der Sensorliste angezeigt.
			\item Bei fehlerhafter Validierung wird Entwickler benachrichtigt und kann die Eingaben korrigieren.
		\end{enumerate}
	\end{itemize}
\end{itemize}

\section{Projektplanung}

\subsection{Projektphasen}
Zur Durchführung des Projektes standen 80 Stunden zur Verfügung. Für die Ausarbeitung des Konzeptes
wird die meiste Zeit eingeplant. Eine ausführliche Projektplanung ist im voraus nötig, allerdings kann auf
Grund fehlender Erfahrung keine genaue Zeit geschätzt werden, es sind 15 Stunden angesetzt. Da der
Autor zum Zeitpunkt der Durchführung dieser Projektarbeit mit den anzubindenden Komponenten und
Problemen bei der täglichen Arbeit in der \acs{GSSD} vertraut ist, wird ein Zeitaufwand von 6 Stunden für die
Analysephase als realistisch eingeschätzt. Die weiteren Phasen werden als unkritisch eingestuft und
sollten in der Ausarbeitung um maximal eine Stunde je Phase abweichen.\\

Tabelle 1 zeigt die grobe Zeitplanung aus dem Projektantrag.


\subsection{Ressourcenplanung}
Anschließend wurden verwendete Ressourcen im Anhang A.2: Verwendete Ressourcen auf Seite ii
aufgelistet, die während des Projekts eingesetzt wurden. Die Planung berücksichtigt sowohl Hard- als auch Software-Ressourcen sowie das beteiligte Personal. Um Kosten zu minimieren, wurde bei der Auswahl der verwendeten Software darauf geachtet, dass keine Lizenzgebühren anfallen, erforderliches Fachwissen vorhanden ist und die Architekturrichtlinien der \acs{GSSD} eingehalten werden.
Die Architekturrichtlinien der \acs{GSSD} legen unter anderem die Nutzung von VSCode als Entwicklungsumgebung und den Jenkins-Server als Werkzeug für die Continuous Integration (CI) fest. Durch die Einhaltung dieser Richtlinien wird sichergestellt, dass das Projekt den Anforderungen der \acs{GSSD} entspricht und nahtlos in die bestehende Infrastruktur integriert werden kann.

\subsection{Entwicklungsprozess}
In der \acs{GSSD} erfolgt die Entwicklung von Kundenprojekten üblicherweise durch den Einsatz der agilen Scrum-Methode. Der Entwicklungsprozess gliedert sich in mehrere ein- oder zweiwöchige Sprints, wobei Gitlab zur Verwaltung der Aufgaben genutzt wird. Die Aufgaben werden den Sprints zugeordnet und während der wöchentlichen Sprintreviews überprüft.\\
Während der Sprintreviews diskutieren alle Projektbeteiligten über den Fortschritt, mögliche Probleme und Herausforderungen. Es werden auch Entscheidungen darüber getroffen, welche Features von welchem Entwickler getestet werden müssen, bevor sie als abgeschlossen betrachtet werden können. Dieser Prozess trägt dazu bei, die Qualität der entwickelten Lösungen sicherzustellen und mögliche Fehler frühzeitig zu erkennen.\\
Die umgesetzten Aufgaben werden gemeinsam kontrolliert, getestet und analysiert, um ein effektives Feedback und kontinuierliche Verbesserungen während des gesamten Entwicklungsprozesses zu gewährleisten. Diese strukturierte und kollaborative Vorgehensweise fördert die Effizienz und Produktivität des Teams und stellt sicher, dass die Kundenprojekte den Anforderungen und Erwartungen entsprechen.\\

\section{Analysephase}
\subsection{Ist-Analyse}
Der Kunde der \acs{GSSD} nutzt auf seinen Servern verschiedene Anwendungen als Dienste oder im Hintergrund.
Um sicherzustellen, dass diese Anwendungen ständig funktionieren, wurde ein Überwachungssystem implementiert.
Allerdings gibt es derzeit Probleme mit der Funktionalität des Systems, da es nur unvollständige Zustände anzeigt.
Die Ist-Analyse ergab Schwachstellen im aktuellen Überwachungssystem, die verbessert werden müssen, um die Zuverlässigkeit und Funktionalität der überwachten Anwendungen sicherzustellen.
Die Analyseergebnisse bilden die Grundlage für die Planung und Umsetzung von Maßnahmen zur Verbesserung des Überwachungssystems.

\subsection{Workflow}

Der Code definiert sowohl ein Datenmodell als auch einen Sensor mit verschiedenen Eigenschaften wie Name, Typ, Datentyp, Einheit, Minimum- und Maximumwert, Status, Zeitstempel und weiteren Optionen.\\
Es gibt zwei Arten von Sensoren: echte Sensoren und virtuelle Sensoren. Echte Sensoren senden kontinuierlich Daten an das Backend, während virtuelle Sensoren SQL-Abfragen an das Backend senden, um Daten aus der Datenbank abzurufen.
\\
\begin{enumerate}
	\item Der Prozess der Sensorregistrierung beginnt damit, dass der Sensorbauer eine API-Anfrage an das Backend sendet und seine Anmeldeinformationen übermittelt. Das Backend prüft, ob der Sensor bereits registriert ist. Wenn nicht, wird der Sensor in der Datenbank registriert und die Anmeldeinformationen werden an den Sensorbauer zurückgesendet.
	\item Nach Erhalt der ID des Sensor kann der Sensor regelmäßig Daten an das Backend übermitteln und Konfigurationsdaten abrufen. Das Backend ruft die Konfigurationsdaten des Sensors über die entsprechende ID aus der Datenbank ab und aktualisiert seine Eigenschaften, wie Name, Typ, Datentyp und Einheit.
	\item Der Sensor kann über die show-Eigenschaft angeben, ob er seine Daten an das Frontend senden und über saveData, ob er seine Daten in der Datenbank speichern möchte. Wenn der Sensor Daten senden möchte, aktualisiert er das Datenfeld im Sensor-Modell und sendet es an das Backend.
	\item Das Backend prüft, ob die Daten gemäß der in der variablen DataRetentionPeriodInMonths festgelegten Aufbewahrungsfrist gespeichert werden sollen. Wenn der saveData-Wert auf true gesetzt ist, speichert das Backend die Daten in der Datenbank und aktualisiert den Sensor-Status und den Zeitstempel.
	\item Wenn der Sensor ein virtueller Sensor ist, kann er über die commendsql-Eigenschaft SQL-Abfragen an das Backend senden, um Daten aus der Datenbank abzurufen. Das Backend führt die Abfrage aus und sendet das Ergebnis an den virtuellen Sensor.
	\item Das Frontend empfängt die Daten von den aktiven Sensoren und aktualisiert die Benutzeroberfläche entsprechend. Das Backend überwacht den Status der Sensoren und informiert den Sensorbauer über Probleme, die auftreten könnten, wie z.B. Sensorausfälle oder Datenbankfehler.
	\item Der Sensorbauer kann über die API auch neue Sensoren registrieren, bestehende Sensoren aktualisieren oder löschen sowie weitere Konfigurationen durchführen. Das Backend stellt hierfür entsprechende Funktionen bereit.
\end{enumerate}



\subsection{Soll-Konzept}
In Zusammenarbeit mit Vorgesetzten wurde das folgende Soll-Konzept entwickelt, welches die vom Kunden gestellten Anforderungen an das Überwachungssystem beschreibt.
Das Überwachungssystem soll alle relevanten Anwendungen auf den Servern des Kunden kontinuierlich überprüfen und bei Fehlererkennung oder Ausfällen den Administrator zuverlässig benachrichtigen. Dabei legt der Kunde Wert auf eine einfache Konfiguration und Verwaltung des Systems.
Um sicherzustellen, dass das Überwachungssystem den Erwartungen des Kunden gerecht wird, müssen zusätzlich bestimmte Leistungskriterien festgelegt werden. Dazu zählen beispielsweise die maximale Anzahl der zu überwachenden Anwendungen, die Reaktionszeit bei Fehlermeldungen und die Verfügbarkeit des Überwachungssystems.

\subsection{Wirtschaftlichkeitsanalyse}
Die Beurteilung der Rentabilität des Projekts für die \acs{GSSD} lässt sich klar feststellen: Der Arbeitsaufwand wurde unter Berücksichtigung des Tagessatzes kalkuliert und dem Kunden ein Angebot unterbreitet. Die angegebene Vergütung deckt die Projektkosten und generiert für das Unternehmen einen finanziellen Gewinn. \\
Eine Wirtschaftlichkeitsanalyse ist daher sinnvoll, wenn man die Vorteile für den Kunden betrachtet. Allerdings ist es schwierig, dies genau zu berechnen, da dem Autor kritische Daten wie täglicher/monatlicher/jährlicher Zeitaufwand und Mitarbeitergehälter des Kunden nicht vorliegen und nicht eingeholt werden können. Dennoch ist davon auszugehen, dass der Kunde die Wirtschaftlichkeit dieser Entscheidung selbst ermittelt und als zufriedenstellend erachtet hat.

\subsubsection{Checkmk}
Checkmk ist eine Monitoring-Lösung für IT-Infrastrukturen, die es Unternehmen ermöglicht, ihre IT-Systeme zu überwachen und Probleme frühzeitig zu erkennen.
Das System nutzt eine Vielzahl von Sensoren, um Informationen über die Systeme zu sammeln und an die Checkmk-Server zu übermitteln.
Checkmk unterstützt auch eine REST-API, die es ermöglicht, auf die Informationen von Checkmk zuzugreifen und diese in anderen Anwendungen zu nutzen.
\\
Die Checkmk-API ermöglicht es, Daten von Checkmk zu extrahieren, um sie in anderen Anwendungen zu nutzen.
Dies kann zum Beispiel dazu genutzt werden, um Informationen über Systemauslastung oder Status von Diensten zu sammeln und in einer anderen Anwendung anzuzeigen.
Die API kann auch dazu genutzt werden, um automatisierte Aktionen auszuführen, wie zum Beispiel das Neustarten von Diensten, wenn diese ausfallen.

\subsubsection{Weitere Fremdsoftware}
Die Entwicklung maßgeschneiderter Software-Lösungen ist eine aufregende Expedition in die Welt der Software-Entwicklung. Bei diesem Projekt liegt das Hauptziel darin, eine Software zu kreieren, die perfekt auf die Bedürfnisse des Kunden zugeschnitten ist. Dabei werde ich innovative Technologien und kreative Ansätze einsetzen, um bestmögliche Ergebnisse zu erzielen.
Die Reise gleicht einer Expedition ins Unbekannte, bei der das Ziel zwar klar ist, jedoch der Weg dorthin voller Herausforderungen steckt. Durch jede Herausforderung wachse ich und sammle wertvolle Erfahrungen, um schlussendlich ein Projekt abzuliefern, das den Kunden begeistert.
Im Laufe des Projekts kann es jedoch vorkommen, dass weitere Fremdsoftware erforderlich ist, um die gesteckten Ziele zu erreichen. In diesem Fall werde ich sorgfältig prüfen, welche Software-Lösungen die Anforderungen am besten erfüllen und diese gezielt einsetzen, um das Projekt erfolgreich abzuschließen.

\subsubsection{Eigenentwicklung}
Die Eigenentwicklung von Software erlaubt es, eine maßgeschneiderte Lösung für spezifische Anforderungen und Bedürfnisse zu schaffen.
Dabei können sowohl der Workflow als auch die Benutzerfreundlichkeit gezielt gestaltet werden.
Ein weiterer Vorteil besteht darin, dass die volle Kontrolle über den Code und dessen Implementierung gegeben ist,
was eine effektive Fehlerbehebung und die Implementierung neuer Funktionalitäten erleichtert.
Darüber hinaus kann die Software kontinuierlich verbessert und angepasst werden,
um den sich ändernden Anforderungen des Anwenders gerecht zu werden.

\subsubsection{Projektkosten}
Im Folgenden werden die Kosten für das Projekt detailliert aufgeschlüsselt. Neben den Personalkosten für Entwickler und weitere Projektbeteiligte sind auch die Kosten für die in Abschnitt 2.2 (Ressourcenplanung) aufgeführten Ressourcen einzuplanen.
\\
Da die genauen Personalkosten vertraulich sind, basiert die Kalkulation auf Stundensätzen, die von der Personalabteilung festgelegt wurden. Diese Stundensätze beinhalten hauptsächlich das Bruttogehalt und die Sozialabgaben des Arbeitgebers. Zusätzlich fallen Kosten für die Nutzung der Ressourcen an.
\\
Für Mitarbeiter wird ein Stundensatz von 35,00 € angesetzt, während der Stundensatz für Auszubildende bei 10,00 € liegt. Für die Ressourcennutzung werden pauschal 15,00 € veranschlagt.
\\
Die Durchführungszeit des Projektes beträgt 80 Stunden. In Tabelle 1: Kostenaufstellung sind die
Kosten unterteilt nach den einzelnen Projektvorgängen aufgelistet, sowie summiert dargestellt, um die
Gesamtkosten, die während des Projektes anfallen, zu erhalten. Diese belaufen sich auf 1015,00€.

\begin{table}[h]
	\centering
	\begin{tabular}{ >{\bfseries}l l r r r }
		\rowcolor[HTML]{127017}
	\textbf{\color{white}Vorgang} & \textbf{\color{white}Mitarbeiter} & \textbf{\color{white}Zeit} & \textbf{\color{white}Personal} & \textbf{\color{white}Gesamt} \\
	Entwicklungskosten im Rahmen der GMS & 1x Auszubildende & 80 & 10,50 & 840,00 \\
	\rowcolor[HTML]{e1efd9}
	Abnahme der Dokumentation & 1x Mitarbeiter & 2h & 35,00€/h & 70,00€ \\
	Aufsicht bei Projektplanung & 1x Mitarbeiter & 1h & 35,00€/h & 35,00€ \\
	\rowcolor[HTML]{e1efd9}
	Hilfestellung bei Problemen & 1x Mitarbeiter & 2h & 35,00€/h & 70,00€ \\
	Pauschalkosten &  &  &  & 15,00€ \\
	\hline
	\rowcolor[HTML]{127017}
	\multicolumn{4}{r}{\textbf{\color{white}Gesamt}} & \textbf{\color{white}1030,00 €} \\
	\end{tabular}
	\caption{Kostenübersicht}
	\label{tab:kostenuebersicht}
	\end{table}

Obwohl die Open-Source-Software NodeJs und VueJs kostenfrei verfügbar sind, verursacht die Implementierung des Projekts dennoch zusätzliche Kosten, die direkt mit der Nutzung dieser Software zusammenhängen. Dazu zählen die Erstellung des Backends zur Nutzung von NodeJs und des Frontends zur Nutzung von VueJs sowie die Entwicklung eines eigenen Überwachungssystems, da keine Alternativen von Checkmk oder anderen Fremdsoftware den speziellen Anforderungen entsprechen.

Die Kostenschätzung der Projektumsetzung erfolgt auf Basis eines Stundensatzes von 10 € pro Stunde, zzgl. 35 € Gemeinkosten, wenn die Implementierung der nachfolgenden Komponenten von einem Programmierer der GSSD durchgeführt wird:

\begin{itemize}
\item Entwicklung des Backends: 10 Stunden (100 € + 35 € Gemeinkosten = 135 €)
\item Entwicklung des Frontends: 15 Stunden (150 € + 35 € Gemeinkosten = 185 €)
\item Entwicklung des Rest-API/Websocket: 10 Stunden (100 € + 35 € Gemeinkosten = 135 €)
\item Implementierung des bereitgestellten Backends bei bestehender Eigensoftware: ca. 1 Arbeitstag pro Programm (je 80 € + 35 € Gemeinkosten = 115 €)
\item Anpassung von Checkmk für jede Fremdsoftware: mindestens 2 Arbeitstage pro Fremdsoftware (je 160 € + 35 € Gemeinkosten = 195 €)
\item Entwicklung der grafischen Benutzeroberfläche: ca. 10 Arbeitstage für die Erstellung von ca. 80 % der Funktionalität inklusive Tests (800 € + 35 € Gemeinkosten = 835 €)
\item Abschließende Schulung: 4 Stunden (40 € + 35 € Gemeinkosten = 75 €)
\end{itemize}

Da das Projekt und alle damit verbundenen Prozesse keinem Kundenprojekt direkt zugeordnet werden können, müssen die Projektkosten mit zukünftigen Projekten verrechnet werden. Daher fallen die Kosten zunächst als variable Kosten im Unternehmen an.

\subsubsection{Amortisationsdauer}
Die Ermittlung der Amortisationsdauer für den Kunden in diesem Projekt gestaltet sich äußerst komplex, da es weder Vergleichsdaten aufgrund fehlender ähnlicher Anwendungen gibt, noch konkrete Zeitaufwandsangaben vorliegen, wie bereits in Abschnitt 3.2 erwähnt.

Für die \acs{GSSD} hingegen amortisiert sich das Projekt relativ schnell, da die im Vertrag mit dem Kunden vereinbarten Personentage monatlich in Rechnung gestellt und beglichen werden. Zusätzliche Kosten, die nach der Inbetriebnahme anfallen, wie beispielsweise die Anmietung von Servern zur Bereitstellung der produktiven Anwendung, werden direkt vom Kunden getragen. Daher entstehen für die \acs{GSSD} keine weiteren Kosten, die nicht durch die Zahlungen des Kunden gedeckt wären.
\subsection{Lastenheft}
Für die Überwachung eines komplexen Systems gibt es verschiedene Ansätze. Ein möglicher Ansatz ist die Erstellung einer Gesamtbewertungsanzeige, die den Zustand des gesamten Systems anzeigt. Dazu können folgende Schritte durchgeführt werden:

\begin{enumerate}
\item Identifikation der relevanten Komponenten und Sensoren
\item Definition von Schwellwerten für jeden Sensor
\item Zusammenfassung der Sensorwerte in einer geeigneten Form
\item Definition von Alarmstufen für jeden Schwellwert
\item Integration von Bewertungsregeln
\item Anzeige der Bewertung auf eine einfache und intuitive Weise
\item Automatische Alarmierung bei kritischen Zuständen des Systems
\item Langzeitanalyse der Sensorwerte für Trends und Muster im Systemverhalten
\item Interaktive Dashboards für detaillierte Ansichten und individuelle Einstellungen.
\end{enumerate}

Durch die Erstellung einer Gesamtbewertungsanzeige können komplexe Systeme effektiv überwacht werden.
Die Anzeige sollte auf eine einfache und intuitive Weise dargestellt werden und automatische Alarmierungen
bei kritischen Zuständen des Systems ermöglichen.
Langzeitanalysen der Sensorwerte können Trends und Muster im Systemverhalten
aufdecken und interaktive Dashboards bieten detaillierte Ansichten und individuelle Einstellungsmöglichkeiten.


\section{Entwurfsphase}

\subsection{Zielplattform}
In der Entwurfsphase wurden technische Anforderungen berücksichtigt und eine Architektur erstellt.
Das System besteht aus Backend und Frontend, welche über Websockets Daten austauschen.
Die Datenbank wurde mit mariaDB realisiert und enthält Tabellen für Anwendungsdaten.
Das Backend (Node.js, Express) liest und bewertet die Daten und das Frontend (Vue.js) zeigt auf einem Dashboard an.
Das System kann Anwendungen hinzufügen und die Filterfunktion einschränken.
Die Entwurfsphase hat klare Vorgaben auf Basis der Kundenanforderungen geschaffen, um sicherzustellen,
dass das System alle notwendigen Anforderungen erfüllt.



\subsection{Architekturdesign}
Das Architekturdesign für die Anwendungsüberwachung besteht aus mehreren Komponenten, die gemeinsam eine umfassende Monitoring-Lösung bieten. Die Architektur beinhaltet das Backend, das Frontend und das Überwachungssystem selbst.
\\
Das Backend wird in Node.js entwickelt und ist für die Verwaltung der Datenbank und der API-Schnittstellen verantwortlich. Es sammelt und analysiert Daten von verschiedenen Anwendungen und speichert sie in der Datenbank. Das Backend verwendet eine REST-API, um die Daten an das Frontend weiterzugeben.
\\
Das Frontend, entwickelt in Vue.js, stellt eine grafische Benutzeroberfläche bereit, die die Anwendungsüberwachung ermöglicht. Es greift auf die API-Schnittstellen des Backends zu, um Daten anzuzeigen und interaktive Funktionen wie das Hinzufügen oder Entfernen von Anwendungen oder das Einstellen von Warnmeldungen bereitzustellen.
\\
Das Überwachungssystem setzt sich aus Sensoren zusammen, die in jeder Anwendung integriert sind und Daten über deren Leistung und Verfügbarkeit sammeln. Diese Sensoren senden in regelmäßigen Abständen Daten an das Backend, um analysiert und gespeichert zu werden. Bei Problemen können die Sensoren automatisch Warnmeldungen auslösen.


\subsection{Entwurf der Benutzeroberfläche}
Der Entwurf der Benutzeroberfläche für das Überwachungssystem besteht aus verschiedenen Elementen, um eine intuitive und ansprechende Umgebung für die Benutzer zu schaffen. Hier sind die Hauptkomponenten des Benutzeroberflächenentwurfs:
\begin{enumerate}
\item Navigation: Eine Seitenleiste oder ein Menü am oberen Rand der Benutzeroberfläche, um den Benutzern den Zugriff auf verschiedene Abschnitte der Anwendung zu ermöglichen, z. B. Dashboard, Anwendungsverwaltung und Einstellungen.
\item Dashboard: Das Dashboard ist der zentrale Bereich der Benutzeroberfläche, in dem die aktuelle Statusinformationen der überwachten Anwendungen angezeigt werden. Es kann Kacheln oder Karten enthalten, die für jede Anwendung einen schnellen Überblick über den Zustand, die Leistung und etwaige Warnmeldungen bieten.
\item Anwendungsverwaltung: In diesem Abschnitt können Benutzer neue Anwendungen hinzufügen, vorhandene Anwendungen entfernen oder konfigurieren und die Sensoren für die Überwachung anpassen.
\item Einstellungen: Ein Bereich für die Verwaltung von Benutzerkonten, Systemeinstellungen und Benachrichtigungsoptionen.
\item Filter- und Suchfunktion: Eine Möglichkeit für Benutzer, die angezeigten Anwendungen und Daten schnell zu filtern oder nach bestimmten Anwendungen oder Kriterien zu suchen.
\item Warnmeldungen: Eine Liste oder ein Bereich, der die aktiven Warnmeldungen und kritischen Ereignisse für die überwachten Anwendungen anzeigt. Benutzer können die Warnmeldungen ein- oder ausblenden und Details zu jedem Ereignis anzeigen.
\item Diagramme und Statistiken: Für jede Anwendung können detaillierte Diagramme und Statistiken zur Leistung und Verfügbarkeit angezeigt werden. Dies kann in Form von Liniendiagrammen, Balkendiagrammen oder Tortendiagrammen erfolgen, je nach Art der Daten und der gewünschten Darstellung.
\item Responsives Design: Die Benutzeroberfläche sollte so gestaltet sein, dass sie auf verschiedenen Bildschirmgrößen und Geräten gut aussieht und funktioniert, einschließlich Desktop-Computern, Tablets und Mobiltelefonen.
\end{enumerate}
Durch die Kombination dieser Elemente wird eine benutzerfreundliche und effektive Benutzeroberfläche geschaffen, die es den Benutzern ermöglicht, die Überwachungsinformationen für ihre Anwendungen leicht zu überprüfen und zu verwalten.

\subsection{Datenmodell}
Basierend auf dem Vertrag zwischen der \acs{GSSD} und dem Kunden sowie den zu berücksichtigenden Anwendungsfällen wurde vom Autor gemeinsam mit dem Entwicklungsteam die erforderliche Datenbankstruktur analysiert und mithilfe von Node.js-Migrationen erstellt.
\\
Diese Datenbankstruktur war auch für die Entwicklung des Frontends von entscheidender Bedeutung, da nahezu jede Entität durch eine eigene Unterseite in der Anwendung repräsentiert wird.
\\
Ein vereinfachtes Entity-Relationship-Modell (ERM), das die Entitäten, Beziehungen und Kardinalitäten zeigt, befindet sich in Anhang A.9. In Anhang A.10 ist ein Screenshot der Datenbank mit ihren Tabellen (dargestellt in IntelliJ) zu finden. Darunter befinden sich auch Tabellen, die nicht formal im ERM dargestellt sind, sondern für andere Zwecke verwendet werden, wie beispielsweise Abonnements, Migrationen und fehlgeschlagene Jobs.





\subsection{Maßnahmen zur Qualitätssicherung}

Ein zentrales Element der agilen Entwicklung bei der \acs{GSSD} ist die Durchführung regelmäßiger, technisch fokussierter Meetings. In diesen Sitzungen werden abgeschlossene Arbeitspakete präsentiert, gemeinsam getestet und gründlich analysiert. Die interdisziplinäre Zusammenarbeit ermöglicht eine fortlaufende Integration der erlangten Erkenntnisse in den Entwicklungsprozess, wodurch die Anwendungsleistung und Codequalität ständig optimiert werden.
\\
Die kontinuierliche Qualitätssicherung ermöglicht es, das Expertenwissen aller Entwickler zu nutzen, um anspruchsvolle Herausforderungen im Entwicklungsprozess effektiv als Team zu bewältigen. Dies resultiert in einer erheblichen Zeitersparnis während der Entwicklung und schafft eine solide Grundlage für eine zukunftssichere und nachhaltige Weiterentwicklung der Anwendung im technischen Bereich.
\\
Um die Qualität des Projekts zu gewährleisten, wurden folgende Maßnahmen umgesetzt:

\begin{enumerate}
\item Unit- und Widget-Tests: Diese Testverfahren validieren die Richtigkeit der Implementierung und sorgen für eine zuverlässige Funktionalität der Anwendung.
\item Regelmäßige Abstimmungen: Die Kommunikation mit dem Entwicklungsleiter dient dazu, Abweichungen frühzeitig zu identifizieren und entsprechende Korrekturmaßnahmen einzuleiten.
\item GIT-Versionsverwaltung: Durch den Einsatz von GIT wird die Transparenz der Softwareentwicklung gewährleistet und die Zusammenarbeit innerhalb des Teams gefördert.
\item Continuous Integration (CI): Mithilfe von Jenkins wird nach jedem Push-Vorgang eine automatische Prüfung der Software durchgeführt, um die Qualität ständig zu überwachen und sicherzustellen.
\end{enumerate}


\subsection{Deployment}
\textcolor{red}{\textbf{TODO}}\\
\subsection{Pflichtenheft}
Zum Abschluss der Entwurfsphase wurde das Pflichtenheft erstellt. Die fachlichen Anforderungen, die gemeinsam mit der Mitarbeiterin aus der \acs{GSSD} im Abschnitt 3.5 (Lastenheft) erarbeitet wurden, bilden die Grundlage für das Pflichtenheft. Mithilfe des Pflichtenhefts kann am Ende überprüft werden, ob alle Anforderungen erfolgreich umgesetzt wurden und das Projektziel erreicht wurde. Das Pflichtenheft ist in Anhang A.19 auf Seite xviii zu finden.

\section{Implementierungsphase}


\subsection{Entwicklung des Dashboards}
In der Entwicklungsphase des Dashboards lag der Fokus auf der Nutzung von wiederverwendbaren und verschachtelbaren Vue-Komponenten, um eine modulare und erweiterbare Benutzeroberfläche zu schaffen. Das Dashboard besteht aus diversen Komponenten, die spezifische Informationen, wie Benutzerstatistiken, Systemzustand oder Leistungskennzahlen, darstellen. Diese Komponenten wurden auf der Dashboard-Seite integriert, um einen umfassenden und aktuellen Einblick in die Leistung des Überwachungssystems zu ermöglichen.

Die einzelnen Dashboard-Komponenten wurden so konzipiert, dass sie sowohl autonom als auch in Kombination miteinander funktionieren. Hierbei wurde die Flexibilität von Vue.js genutzt, um die Anordnung und Darstellung der Komponenten dynamisch an die Erfordernisse des Projekts anzupassen. Ein Beispiel hierfür ist die Implementierung von vuetify, einem Material Design Framework für Vue.js, das eine Vielzahl von vordefinierten Komponenten und Layouts bereitstellt.

Dank der Anwendung asynchroner Funktionen und reaktiver Daten innerhalb der Dashboard-Komponenten werden die dargestellten Informationen kontinuierlich aktualisiert und auf dem neuesten Stand gehalten. Dies ermöglicht die Echtzeitüberwachung verschiedener Systemaspekte und trägt zur raschen Identifizierung von Problemen und Leistungseinbußen bei.

Im Anhang sind beispielhafte Screenshots des entwickelten Dashboards enthalten, die verschiedene Komponenten und ihre Anordnung innerhalb der Benutzeroberfläche verdeutlichen. Diese Screenshots zeigen, wie das Dashboard eine strukturierte und benutzerfreundliche Visualisierung relevanter Informationen bietet und gleichzeitig flexibel genug ist, um an die spezifischen Anforderungen des Überwachungsprojekts angepasst zu werden.

\subsection{Datenbank}
Die verwendete Datenbank für das Projekt ist mariaDB. mariaDB ist ein weit verbreitetes, relationales Datenbankmanagementsystem, das sich durch seine Skalierbarkeit und Flexibilität auszeichnet. Es ist Open-Source und kann kostenfrei genutzt werden.\\
Die Integration von mariaDB in das Backend ermöglicht die effiziente Verwaltung und Speicherung der gesammelten Daten aus den verschiedenen Anwendungen. Durch die Verwendung von mariaDB können auch komplexe Abfragen und Analysen der gespeicherten Daten durchgeführt werden, um wertvolle Erkenntnisse über die Leistung und Verfügbarkeit der überwachten Anwendungen zu gewinnen.\\
Die Verbindung zwischen dem Backend und der mariaDB-Datenbank wird über entsprechende Treiber und Bibliotheken in Node.js hergestellt. Die Datenbankstruktur wird so gestaltet, dass sie leicht erweitert und angepasst werden kann, um neue Anwendungen oder Sensoren hinzuzufügen oder um zusätzliche Funktionen und Warnmeldungen zu unterstützen.\\
Insgesamt bietet die Verwendung von mariaDB als Datenbanklösung für das Projekt eine robuste und skalierbare Grundlage, die den Anforderungen des Kunden gerecht wird und die Möglichkeit bietet, das Überwachungssystem im Laufe der Zeit weiterzuentwickeln und zu optimieren.\\


\subsection{REST-API}
In diesem Projekt wird eine REST-API verwendet, um den Datenaustausch zwischen den Sensoren und dem Backend zu ermöglichen. Die REST-API stellt eine standardisierte und leicht zu verwendende Schnittstelle bereit, um Daten zwischen diesen Systemkomponenten auszutauschen.
\\
Die Hauptmerkmale der in diesem Projekt verwendeten REST-API sind:
\begin{enumerate}
\item Zustandslosigkeit: Jede Anfrage von Client zu Server enthält alle notwendigen Informationen, sodass der Server den Kontext der Anfrage nicht speichern muss. Dies führt zu einer besseren Skalierbarkeit und Vereinfachung der Serverlogik.
\item Cache-Fähigkeit: Die API-Antworten können gecacht werden, um die Leistung zu verbessern und die Last auf dem Server zu reduzieren.
\item Client-Server-Architektur: Die REST-API trennt die Benutzeroberfläche (Frontend) von der Backend-Logik und der Datenverarbeitung. Dies erlaubt eine unabhängige Entwicklung und Verbesserung der einzelnen Komponenten.
\item Einheitliche Schnittstelle: Die REST-API stellt eine einheitliche und konsistente Schnittstelle bereit, die die Interaktion zwischen den Komponenten vereinfacht.
\end{enumerate}

Im Kontext des Projekts werden die Sensoren die REST-API verwenden, um Daten an das Backend zu senden oder abzufragen. Das Backend empfängt die Daten von den Sensoren, analysiert und speichert sie in der Datenbank.

Für die Kommunikation zwischen dem Backend und dem Frontend wird ein Websocket verwendet. Dies ermöglicht eine bidirektionale Kommunikation in Echtzeit zwischen den beiden Komponenten. Das Frontend verwendet den Websocket, um die Daten vom Backend abzurufen und sie in einer benutzerfreundlichen Weise darzustellen.

Die Verwendung der REST-API für die Sensoren und des Websockets für die Kommunikation zwischen Backend und Frontend gewährleistet eine effiziente und zuverlässige Kommunikation, wodurch ein effektives Überwachungssystem für die Anwendungen auf den Servern
des Kunden geschaffen wird.



\subsection{Testen der Anwendung}
Um sicherzustellen, dass die entwickelte Anwendung fehlerfrei funktionierte und die definierten Anforderungen erfüllte, war ein systematischer Testprozess erforderlich. Hierbei kamen verschiedene Testansätze und -ebenen zum Einsatz:

\begin{enumerate}
\item Unit-Tests
\begin{itemize}
\item Unit-Tests konzentrierten sich auf einzelne Codeeinheiten wie Funktionen oder Klassen. Sie gewährleisteten, dass diese korrekt arbeiteten und die erwarteten Ergebnisse lieferten.
\item In der Regel wurden Unit-Tests mit Hilfe von Test-Frameworks wie JUnit Mocha (für JavaScript) erstellt und automatisiert ausgeführt.
\end{itemize}
\item Integrationstests
\begin{itemize}
\item Integrationstests überprüften die korrekte Interaktion zwischen verschiedenen Komponenten der Anwendung, wie zum Beispiel Datenbankzugriffe oder Kommunikation zwischen Backend und Frontend.
\item Diese Tests wurden sowohl auf Code- als auch auf Systemebene durchgeführt, abhängig von den zu testenden Komponenten.
\end{itemize}
\item Systemtests
\begin{itemize}
\item Systemtests prüften die Anwendung in ihrer Gesamtheit, um sicherzustellen, dass alle Komponenten ordnungsgemäß zusammenspielten und die Anwendung wie beabsichtigt funktionierte.
\item Diese Tests umfassten oft auch Last- und Performance-Tests, um die Leistungsfähigkeit und Stabilität der Anwendung unter verschiedenen Bedingungen zu überprüfen.
\end{itemize}
\item Akzeptanztests
\begin{itemize}
\item Akzeptanztests, auch bekannt als End-to-End-Tests oder Benutzertests, stellten sicher, dass die Anwendung den Anforderungen der Endbenutzer entsprach und alle definierten Use Cases abdeckte.
\item Diese Tests wurden manuell durchgeführt oder mithilfe von Test-Tools wie Selenium automatisiert, um Benutzerinteraktionen mit der Anwendung zu simulieren.
\end{itemize}
\end{enumerate}

Ein effektiver Testprozess umfasste sowohl manuelle als auch automatisierte Tests und folgte den Prinzipien des Test-Driven Development (TDD) oder Behavior-Driven Development (BDD), bei denen Tests als integraler Bestandteil des Entwicklungsprozesses betrachtet wurden. Regelmäßige Code-Reviews und die Verwendung von Continuous Integration (CI) und Continuous Deployment (CD) trugen ebenfalls zur Qualitätssicherung der Anwendung bei.


\section{Abnahmephase}

\subsection{Code-Review}
Code-Reviews waren ein wesentlicher Bestandteil des Entwicklungsprozesses, um die Codequalität zu gewährleisten und eine kontinuierliche Verbesserung des Codes zu fördern. Sie dienten dazu, potenzielle Fehler frühzeitig zu erkennen und Best Practices für die Codeentwicklung zu fördern.

Während des Entwicklungsprozesses wurden Code-Reviews durchgeführt, um sicherzustellen, dass:

\begin{enumerate}
\item Der Code den vereinbarten Programmierstandards und Richtlinien entsprach.
\item Der Code gut strukturiert, lesbar und wartbar war.
\item Der Code effizient und performant war.
\item Der Code frei von Sicherheitslücken und Anfälligkeiten war.
\item Der Code keine unbeabsichtigten Seiteneffekte oder Regressionen verursachte.
\end{enumerate}

Um Code-Reviews effektiv zu gestalten, wurden folgende Best Practices angewendet:

\begin{enumerate}
\item Die Verwendung von Pull Requests (PRs) in Git, um Änderungen am Code vor der Integration in den Hauptzweig zu überprüfen. Dies ermöglichte es den Entwicklern, Feedback zu geben und Probleme gemeinsam zu lösen.
\item Die Einhaltung einer Checkliste für Code-Reviews, um sicherzustellen, dass alle wichtigen Aspekte des Codes überprüft wurden.
\item Die Durchführung von regelmäßigen Code-Review-Sitzungen, bei denen das Team gemeinsam den Code durchging und mögliche Verbesserungen besprach.
\item Die Förderung einer offenen und konstruktiven Feedbackkultur, bei der Entwickler ermutigt wurden, Fragen zu stellen, Bedenken zu äußern und Vorschläge zur Verbesserung des Codes zu machen.
\item Die kontinuierliche Verbesserung der Code-Review-Prozesse durch regelmäßiges Feedback und Anpassungen an den Bedürfnissen des Teams.
\end{enumerate}

Durch das Implementieren dieser Praktiken wurden Code-Reviews zu einem wichtigen Instrument zur Qualitätssicherung und zur Verbesserung der Zusammenarbeit im Team

\subsection{Abnahme}
Im Rahmen dieses Projekts fand keine separate Abnahmephase statt. Stattdessen wurden die Anwendung, ihre Benutzeroberfläche sowie die Interaktion zwischen Frontend und Backend kontinuierlich während des Entwicklungsprozesses in gemeinsamen Sprint-Reviews getestet und besprochen. Durch diesen Ansatz konnte eine interne Abnahme des Projekts bereits während der Entwicklungsphase sichergestellt werden.

Trotzdem wurde eine formelle Testphase der Benutzeroberfläche, einschließlich JavaScript-Testfällen, durchgeführt. Aufgrund zeitlicher Verzögerungen kann diese Phase jedoch nicht ausführlich in dieser Projektdokumentation erklärt und berücksichtigt werden.


\section{Dokumentation}
Im Rahmen des Projektabschlusses für das spezifische Projekt, das sich auf die Entwicklung einer webbasierten Anwendung für die \acs{GSSD} konzentriert, wurden zwei zentrale Dokumentationen erstellt, um sowohl Endanwendern als auch Entwicklern eine umfassende Informationsquelle zur Verfügung zu stellen. Beide Dokumente wurden fachlich fundiert und ansprechend gestaltet, um ihren jeweiligen Zielgruppen den bestmöglichen Nutzen zu bieten. Im Folgenden werden die spezifischen Ziele und Inhalte dieser Dokumentationen in Bezug auf das Projekt erläutert:
\subsection{Benutzerhandbuch Endanwender-Dokumentation}

Das Benutzerhandbuch wurde für die Endanwender der \acs{GSSD} Anwendung konzipiert und bietet eine systematische Einführung in die Plattform, ihre Funktionen und Bedienung. Hierbei wurden ansprechende visuelle Darstellungen und präzise Anweisungen verwendet, um den Anwendern ein effizientes und angenehmes Nutzungserlebnis zu ermöglichen. Das Handbuch enthält detaillierte Schritt-für-Schritt-Anleitungen zur Verwendung der verschiedenen Module und Funktionen der Anwendung, wie z.B. Datenverwaltung, Berichterstellung und Zusammenarbeit zwischen verschiedenen Nutzergruppen. Zudem werden Best Practices und nützliche Tipps für den optimalen Einsatz der Software innerhalb der \acs{GSSD} bereitgestellt.

\subsection{Entwicklerdokumentation}
Die Entwicklerdokumentation richtet sich an Fachleute, die an der Weiterentwicklung, Wartung oder Integration der \acs{GSSD}-Anwendung beteiligt sind. Diese Dokumentation wurde sorgfältig erstellt, um ein tiefgehendes Verständnis der technischen Aspekte der Software zu vermitteln, einschließlich ihrer Architektur, des Codes, der verwendeten Technologien wie NodeJs, VueJs und MariaDB sowie der eingesetzten Bibliotheken und Frameworks. Um den Entwicklern eine strukturierte Orientierungshilfe zu bieten, wurden Best Practices und Richtlinien für die Projektstruktur, das Einrichten der Entwicklungsumgebung, das Durchführen von Tests und das Hinzufügen neuer Funktionen integriert. Die Entwicklerdokumentation soll somit eine solide Grundlage für eine effektive Zusammenarbeit und eine qualitativ hochwertige Weiterentwicklung des \acs{GSSD}-Projekts schaffen.

\section{Fazit}
\subsection{Soll-\/Ist-Vergleich}
\textcolor{red}{\textbf{Durchs Vergleich zwischen dem Produkt was am Ende kommt und dem Lasten Heft, kann man sagen, dass der Produkt alle erwünschten Kriterien erf\"ullt.}}
\\
\end{flushleft}
